import{generateSecret as k}from"@otplib/core";import{createGuardrails as S}from"@otplib/core";import{ScureBase32Plugin as V}from"@otplib/plugin-base32-scure";import{NobleCryptoPlugin as R}from"@otplib/plugin-crypto-noble";var g=Object.freeze(new R),u=Object.freeze(new V);function l(t){return{secret:t.secret,strategy:t.strategy??"totp",crypto:t.crypto??g,base32:t.base32??u,algorithm:t.algorithm??"sha1",digits:t.digits??6,period:t.period??30,epoch:t.epoch??Math.floor(Date.now()/1e3),t0:t.t0??0,counter:t.counter,guardrails:t.guardrails??S()}}function f(t){return{...l(t),token:t.token,epochTolerance:t.epochTolerance??0,counterTolerance:t.counterTolerance??0}}import{generateSecret as q,ConfigurationError as m}from"@otplib/core";import{generate as G,generateSync as x,verify as H,verifySync as v}from"@otplib/hotp";import{generate as C,generateSync as D,verify as B,verifySync as U}from"@otplib/totp";import{generateTOTP as w,generateHOTP as I}from"@otplib/uri";function y(t,e,r){if(t==="totp")return r.totp();if(t==="hotp"){if(e===void 0)throw new m("Counter is required for HOTP strategy. Example: { strategy: 'hotp', counter: 0 }");return r.hotp(e)}throw new m(`Unknown OTP strategy: ${t}. Valid strategies are 'totp' or 'hotp'.`)}function O(t){let{strategy:e="totp",issuer:r,label:o,secret:i,algorithm:a="sha1",digits:p=6,period:s=30,counter:n}=t;return y(e,n,{totp:()=>w({issuer:r,label:o,secret:i,algorithm:a,digits:p,period:s}),hotp:c=>I({issuer:r,label:o,secret:i,algorithm:a,digits:p,counter:c})})}async function T(t){let e=l(t),{secret:r,crypto:o,base32:i,algorithm:a,digits:p}=e,s={secret:r,crypto:o,base32:i,algorithm:a,digits:p};return y(e.strategy,e.counter,{totp:()=>C({...s,period:e.period,epoch:e.epoch,t0:e.t0,guardrails:e.guardrails}),hotp:n=>G({...s,counter:n,guardrails:e.guardrails})})}function h(t){let e=l(t),{secret:r,crypto:o,base32:i,algorithm:a,digits:p}=e,s={secret:r,crypto:o,base32:i,algorithm:a,digits:p};return y(e.strategy,e.counter,{totp:()=>D({...s,period:e.period,epoch:e.epoch,t0:e.t0,guardrails:e.guardrails}),hotp:n=>x({...s,counter:n,guardrails:e.guardrails})})}async function P(t){let e=f(t),{secret:r,token:o,crypto:i,base32:a,algorithm:p,digits:s}=e,n={secret:r,token:o,crypto:i,base32:a,algorithm:p,digits:s};return y(e.strategy,e.counter,{totp:()=>B({...n,period:e.period,epoch:e.epoch,t0:e.t0,epochTolerance:e.epochTolerance,guardrails:e.guardrails}),hotp:c=>H({...n,counter:c,counterTolerance:e.counterTolerance,guardrails:e.guardrails})})}function d(t){let e=f(t),{secret:r,token:o,crypto:i,base32:a,algorithm:p,digits:s}=e,n={secret:r,token:o,crypto:i,base32:a,algorithm:p,digits:s};return y(e.strategy,e.counter,{totp:()=>U({...n,period:e.period,epoch:e.epoch,t0:e.t0,epochTolerance:e.epochTolerance,guardrails:e.guardrails}),hotp:c=>v({...n,counter:c,counterTolerance:e.counterTolerance,guardrails:e.guardrails})})}var b=class{strategy;crypto;base32;constructor(e={}){let{strategy:r="totp",crypto:o=g,base32:i=u}=e;this.strategy=r,this.crypto=o,this.base32=i}getStrategy(){return this.strategy}generateSecret(e=20){return k({crypto:this.crypto,base32:this.base32,length:e})}async generate(e){return T({...e,strategy:this.strategy,crypto:this.crypto,base32:this.base32})}generateSync(e){return h({...e,strategy:this.strategy,crypto:this.crypto,base32:this.base32})}async verify(e){return P({...e,strategy:this.strategy,crypto:this.crypto,base32:this.base32})}verifySync(e){return d({...e,strategy:this.strategy,crypto:this.crypto,base32:this.base32})}generateURI(e){return O({...e,strategy:this.strategy})}};export{b as OTP};
//# sourceMappingURL=class.js.map