"use strict";var h=Object.defineProperty;var D=Object.getOwnPropertyDescriptor;var B=Object.getOwnPropertyNames;var U=Object.prototype.hasOwnProperty;var w=(t,e)=>{for(var r in e)h(t,r,{get:e[r],enumerable:!0})},I=(t,e,r,i)=>{if(e&&typeof e=="object"||typeof e=="function")for(let o of B(e))!U.call(t,o)&&o!==r&&h(t,o,{get:()=>e[o],enumerable:!(i=D(e,o))||i.enumerable});return t};var k=t=>I(h({},"__esModule",{value:!0}),t);var z={};w(z,{OTP:()=>d});module.exports=k(z);var C=require("@otplib/core");var b=require("@otplib/core"),S=require("@otplib/plugin-base32-scure"),V=require("@otplib/plugin-crypto-noble"),l=Object.freeze(new V.NobleCryptoPlugin),f=Object.freeze(new S.ScureBase32Plugin);function m(t){return{secret:t.secret,strategy:t.strategy??"totp",crypto:t.crypto??l,base32:t.base32??f,algorithm:t.algorithm??"sha1",digits:t.digits??6,period:t.period??30,epoch:t.epoch??Math.floor(Date.now()/1e3),t0:t.t0??0,counter:t.counter,guardrails:t.guardrails??(0,b.createGuardrails)()}}function P(t){return{...m(t),token:t.token,epochTolerance:t.epochTolerance??0,counterTolerance:t.counterTolerance??0}}var O=require("@otplib/core"),c=require("@otplib/hotp"),y=require("@otplib/totp"),T=require("@otplib/uri");function u(t,e,r){if(t==="totp")return r.totp();if(t==="hotp"){if(e===void 0)throw new O.ConfigurationError("Counter is required for HOTP strategy. Example: { strategy: 'hotp', counter: 0 }");return r.hotp(e)}throw new O.ConfigurationError(`Unknown OTP strategy: ${t}. Valid strategies are 'totp' or 'hotp'.`)}function R(t){let{strategy:e="totp",issuer:r,label:i,secret:o,algorithm:a="sha1",digits:p=6,period:s=30,counter:n}=t;return u(e,n,{totp:()=>(0,T.generateTOTP)({issuer:r,label:i,secret:o,algorithm:a,digits:p,period:s}),hotp:g=>(0,T.generateHOTP)({issuer:r,label:i,secret:o,algorithm:a,digits:p,counter:g})})}async function G(t){let e=m(t),{secret:r,crypto:i,base32:o,algorithm:a,digits:p}=e,s={secret:r,crypto:i,base32:o,algorithm:a,digits:p};return u(e.strategy,e.counter,{totp:()=>(0,y.generate)({...s,period:e.period,epoch:e.epoch,t0:e.t0,guardrails:e.guardrails}),hotp:n=>(0,c.generate)({...s,counter:n,guardrails:e.guardrails})})}function x(t){let e=m(t),{secret:r,crypto:i,base32:o,algorithm:a,digits:p}=e,s={secret:r,crypto:i,base32:o,algorithm:a,digits:p};return u(e.strategy,e.counter,{totp:()=>(0,y.generateSync)({...s,period:e.period,epoch:e.epoch,t0:e.t0,guardrails:e.guardrails}),hotp:n=>(0,c.generateSync)({...s,counter:n,guardrails:e.guardrails})})}async function H(t){let e=P(t),{secret:r,token:i,crypto:o,base32:a,algorithm:p,digits:s}=e,n={secret:r,token:i,crypto:o,base32:a,algorithm:p,digits:s};return u(e.strategy,e.counter,{totp:()=>(0,y.verify)({...n,period:e.period,epoch:e.epoch,t0:e.t0,epochTolerance:e.epochTolerance,guardrails:e.guardrails}),hotp:g=>(0,c.verify)({...n,counter:g,counterTolerance:e.counterTolerance,guardrails:e.guardrails})})}function v(t){let e=P(t),{secret:r,token:i,crypto:o,base32:a,algorithm:p,digits:s}=e,n={secret:r,token:i,crypto:o,base32:a,algorithm:p,digits:s};return u(e.strategy,e.counter,{totp:()=>(0,y.verifySync)({...n,period:e.period,epoch:e.epoch,t0:e.t0,epochTolerance:e.epochTolerance,guardrails:e.guardrails}),hotp:g=>(0,c.verifySync)({...n,counter:g,counterTolerance:e.counterTolerance,guardrails:e.guardrails})})}var d=class{strategy;crypto;base32;constructor(e={}){let{strategy:r="totp",crypto:i=l,base32:o=f}=e;this.strategy=r,this.crypto=i,this.base32=o}getStrategy(){return this.strategy}generateSecret(e=20){return(0,C.generateSecret)({crypto:this.crypto,base32:this.base32,length:e})}async generate(e){return G({...e,strategy:this.strategy,crypto:this.crypto,base32:this.base32})}generateSync(e){return x({...e,strategy:this.strategy,crypto:this.crypto,base32:this.base32})}async verify(e){return H({...e,strategy:this.strategy,crypto:this.crypto,base32:this.base32})}verifySync(e){return v({...e,strategy:this.strategy,crypto:this.crypto,base32:this.base32})}generateURI(e){return R({...e,strategy:this.strategy})}};0&&(module.exports={OTP});
//# sourceMappingURL=class.cjs.map