import{generateSecret as h,ConfigurationError as O}from"@otplib/core";import{generate as P,generateSync as S,verify as b,verifySync as V}from"@otplib/hotp";import{generate as x,generateSync as H,verify as R,verifySync as v}from"@otplib/totp";import{generateTOTP as G,generateHOTP as w}from"@otplib/uri";import{createGuardrails as T}from"@otplib/core";import{ScureBase32Plugin as m}from"@otplib/plugin-base32-scure";import{NobleCryptoPlugin as d}from"@otplib/plugin-crypto-noble";var l=Object.freeze(new d),y=Object.freeze(new m);function u(t){return{secret:t.secret,strategy:t.strategy??"totp",crypto:t.crypto??l,base32:t.base32??y,algorithm:t.algorithm??"sha1",digits:t.digits??6,period:t.period??30,epoch:t.epoch??Math.floor(Date.now()/1e3),t0:t.t0??0,counter:t.counter,guardrails:t.guardrails??T()}}function f(t){return{...u(t),token:t.token,epochTolerance:t.epochTolerance??0,counterTolerance:t.counterTolerance??0}}function g(t,e,r){if(t==="totp")return r.totp();if(t==="hotp"){if(e===void 0)throw new O("Counter is required for HOTP strategy. Example: { strategy: 'hotp', counter: 0 }");return r.hotp(e)}throw new O(`Unknown OTP strategy: ${t}. Valid strategies are 'totp' or 'hotp'.`)}function A(t){let{crypto:e=l,base32:r=y,length:o=20}=t||{};return h({crypto:e,base32:r,length:o})}function E(t){let{strategy:e="totp",issuer:r,label:o,secret:a,algorithm:s="sha1",digits:p=6,period:n=30,counter:i}=t;return g(e,i,{totp:()=>G({issuer:r,label:o,secret:a,algorithm:s,digits:p,period:n}),hotp:c=>w({issuer:r,label:o,secret:a,algorithm:s,digits:p,counter:c})})}async function q(t){let e=u(t),{secret:r,crypto:o,base32:a,algorithm:s,digits:p}=e,n={secret:r,crypto:o,base32:a,algorithm:s,digits:p};return g(e.strategy,e.counter,{totp:()=>x({...n,period:e.period,epoch:e.epoch,t0:e.t0,guardrails:e.guardrails}),hotp:i=>P({...n,counter:i,guardrails:e.guardrails})})}function M(t){let e=u(t),{secret:r,crypto:o,base32:a,algorithm:s,digits:p}=e,n={secret:r,crypto:o,base32:a,algorithm:s,digits:p};return g(e.strategy,e.counter,{totp:()=>H({...n,period:e.period,epoch:e.epoch,t0:e.t0,guardrails:e.guardrails}),hotp:i=>S({...n,counter:i,guardrails:e.guardrails})})}async function N(t){let e=f(t),{secret:r,token:o,crypto:a,base32:s,algorithm:p,digits:n}=e,i={secret:r,token:o,crypto:a,base32:s,algorithm:p,digits:n};return g(e.strategy,e.counter,{totp:()=>R({...i,period:e.period,epoch:e.epoch,t0:e.t0,epochTolerance:e.epochTolerance,guardrails:e.guardrails}),hotp:c=>b({...i,counter:c,counterTolerance:e.counterTolerance,guardrails:e.guardrails})})}function $(t){let e=f(t),{secret:r,token:o,crypto:a,base32:s,algorithm:p,digits:n}=e,i={secret:r,token:o,crypto:a,base32:s,algorithm:p,digits:n};return g(e.strategy,e.counter,{totp:()=>v({...i,period:e.period,epoch:e.epoch,t0:e.t0,epochTolerance:e.epochTolerance,guardrails:e.guardrails}),hotp:c=>V({...i,counter:c,counterTolerance:e.counterTolerance,guardrails:e.guardrails})})}export{q as generate,A as generateSecret,M as generateSync,E as generateURI,N as verify,$ as verifySync};
//# sourceMappingURL=functional.js.map