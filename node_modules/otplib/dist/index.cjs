"use strict";var x=Object.defineProperty;var k=Object.getOwnPropertyDescriptor;var z=Object.getOwnPropertyNames;var W=Object.prototype.hasOwnProperty;var E=(t,e)=>{for(var r in e)x(t,r,{get:e[r],enumerable:!0})},F=(t,e,r,i)=>{if(e&&typeof e=="object"||typeof e=="function")for(let o of z(e))!W.call(t,o)&&o!==r&&x(t,o,{get:()=>e[o],enumerable:!(i=k(e,o))||i.enumerable});return t};var N=t=>F(x({},"__esModule",{value:!0}),t);var q={};E(q,{HOTP:()=>w.HOTP,NobleCryptoPlugin:()=>A.NobleCryptoPlugin,OTP:()=>V,ScureBase32Plugin:()=>j.ScureBase32Plugin,TOTP:()=>I.TOTP,createGuardrails:()=>U.createGuardrails,generate:()=>h,generateSecret:()=>B,generateSync:()=>d,generateURI:()=>P,verify:()=>b,verifySync:()=>S,wrapResult:()=>R.wrapResult,wrapResultAsync:()=>R.wrapResultAsync});module.exports=N(q);var f=require("@otplib/core"),y=require("@otplib/hotp"),c=require("@otplib/totp"),T=require("@otplib/uri");var H=require("@otplib/core"),v=require("@otplib/plugin-base32-scure"),C=require("@otplib/plugin-crypto-noble"),u=Object.freeze(new C.NobleCryptoPlugin),l=Object.freeze(new v.ScureBase32Plugin);function m(t){return{secret:t.secret,strategy:t.strategy??"totp",crypto:t.crypto??u,base32:t.base32??l,algorithm:t.algorithm??"sha1",digits:t.digits??6,period:t.period??30,epoch:t.epoch??Math.floor(Date.now()/1e3),t0:t.t0??0,counter:t.counter,guardrails:t.guardrails??(0,H.createGuardrails)()}}function G(t){return{...m(t),token:t.token,epochTolerance:t.epochTolerance??0,counterTolerance:t.counterTolerance??0}}function O(t,e,r){if(t==="totp")return r.totp();if(t==="hotp"){if(e===void 0)throw new f.ConfigurationError("Counter is required for HOTP strategy. Example: { strategy: 'hotp', counter: 0 }");return r.hotp(e)}throw new f.ConfigurationError(`Unknown OTP strategy: ${t}. Valid strategies are 'totp' or 'hotp'.`)}function B(t){let{crypto:e=u,base32:r=l,length:i=20}=t||{};return(0,f.generateSecret)({crypto:e,base32:r,length:i})}function P(t){let{strategy:e="totp",issuer:r,label:i,secret:o,algorithm:a="sha1",digits:p=6,period:n=30,counter:s}=t;return O(e,s,{totp:()=>(0,T.generateTOTP)({issuer:r,label:i,secret:o,algorithm:a,digits:p,period:n}),hotp:g=>(0,T.generateHOTP)({issuer:r,label:i,secret:o,algorithm:a,digits:p,counter:g})})}async function h(t){let e=m(t),{secret:r,crypto:i,base32:o,algorithm:a,digits:p}=e,n={secret:r,crypto:i,base32:o,algorithm:a,digits:p};return O(e.strategy,e.counter,{totp:()=>(0,c.generate)({...n,period:e.period,epoch:e.epoch,t0:e.t0,guardrails:e.guardrails}),hotp:s=>(0,y.generate)({...n,counter:s,guardrails:e.guardrails})})}function d(t){let e=m(t),{secret:r,crypto:i,base32:o,algorithm:a,digits:p}=e,n={secret:r,crypto:i,base32:o,algorithm:a,digits:p};return O(e.strategy,e.counter,{totp:()=>(0,c.generateSync)({...n,period:e.period,epoch:e.epoch,t0:e.t0,guardrails:e.guardrails}),hotp:s=>(0,y.generateSync)({...n,counter:s,guardrails:e.guardrails})})}async function b(t){let e=G(t),{secret:r,token:i,crypto:o,base32:a,algorithm:p,digits:n}=e,s={secret:r,token:i,crypto:o,base32:a,algorithm:p,digits:n};return O(e.strategy,e.counter,{totp:()=>(0,c.verify)({...s,period:e.period,epoch:e.epoch,t0:e.t0,epochTolerance:e.epochTolerance,guardrails:e.guardrails}),hotp:g=>(0,y.verify)({...s,counter:g,counterTolerance:e.counterTolerance,guardrails:e.guardrails})})}function S(t){let e=G(t),{secret:r,token:i,crypto:o,base32:a,algorithm:p,digits:n}=e,s={secret:r,token:i,crypto:o,base32:a,algorithm:p,digits:n};return O(e.strategy,e.counter,{totp:()=>(0,c.verifySync)({...s,period:e.period,epoch:e.epoch,t0:e.t0,epochTolerance:e.epochTolerance,guardrails:e.guardrails}),hotp:g=>(0,y.verifySync)({...s,counter:g,counterTolerance:e.counterTolerance,guardrails:e.guardrails})})}var D=require("@otplib/core");var V=class{strategy;crypto;base32;constructor(e={}){let{strategy:r="totp",crypto:i=u,base32:o=l}=e;this.strategy=r,this.crypto=i,this.base32=o}getStrategy(){return this.strategy}generateSecret(e=20){return(0,D.generateSecret)({crypto:this.crypto,base32:this.base32,length:e})}async generate(e){return h({...e,strategy:this.strategy,crypto:this.crypto,base32:this.base32})}generateSync(e){return d({...e,strategy:this.strategy,crypto:this.crypto,base32:this.base32})}async verify(e){return b({...e,strategy:this.strategy,crypto:this.crypto,base32:this.base32})}verifySync(e){return S({...e,strategy:this.strategy,crypto:this.crypto,base32:this.base32})}generateURI(e){return P({...e,strategy:this.strategy})}};var U=require("@otplib/core"),w=require("@otplib/hotp"),I=require("@otplib/totp"),R=require("@otplib/core"),A=require("@otplib/plugin-crypto-noble"),j=require("@otplib/plugin-base32-scure");0&&(module.exports={HOTP,NobleCryptoPlugin,OTP,ScureBase32Plugin,TOTP,createGuardrails,generate,generateSecret,generateSync,generateURI,verify,verifySync,wrapResult,wrapResultAsync});
//# sourceMappingURL=index.cjs.map