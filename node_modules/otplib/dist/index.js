import{generateSecret as x,ConfigurationError as b}from"@otplib/core";import{generate as G,generateSync as H,verify as v,verifySync as C}from"@otplib/hotp";import{generate as B,generateSync as D,verify as U,verifySync as w}from"@otplib/totp";import{generateTOTP as I,generateHOTP as A}from"@otplib/uri";import{createGuardrails as S}from"@otplib/core";import{ScureBase32Plugin as V}from"@otplib/plugin-base32-scure";import{NobleCryptoPlugin as R}from"@otplib/plugin-crypto-noble";var c=Object.freeze(new R),g=Object.freeze(new V);function l(t){return{secret:t.secret,strategy:t.strategy??"totp",crypto:t.crypto??c,base32:t.base32??g,algorithm:t.algorithm??"sha1",digits:t.digits??6,period:t.period??30,epoch:t.epoch??Math.floor(Date.now()/1e3),t0:t.t0??0,counter:t.counter,guardrails:t.guardrails??S()}}function f(t){return{...l(t),token:t.token,epochTolerance:t.epochTolerance??0,counterTolerance:t.counterTolerance??0}}function u(t,e,r){if(t==="totp")return r.totp();if(t==="hotp"){if(e===void 0)throw new b("Counter is required for HOTP strategy. Example: { strategy: 'hotp', counter: 0 }");return r.hotp(e)}throw new b(`Unknown OTP strategy: ${t}. Valid strategies are 'totp' or 'hotp'.`)}function j(t){let{crypto:e=c,base32:r=g,length:o=20}=t||{};return x({crypto:e,base32:r,length:o})}function O(t){let{strategy:e="totp",issuer:r,label:o,secret:i,algorithm:a="sha1",digits:p=6,period:n=30,counter:s}=t;return u(e,s,{totp:()=>I({issuer:r,label:o,secret:i,algorithm:a,digits:p,period:n}),hotp:y=>A({issuer:r,label:o,secret:i,algorithm:a,digits:p,counter:y})})}async function m(t){let e=l(t),{secret:r,crypto:o,base32:i,algorithm:a,digits:p}=e,n={secret:r,crypto:o,base32:i,algorithm:a,digits:p};return u(e.strategy,e.counter,{totp:()=>B({...n,period:e.period,epoch:e.epoch,t0:e.t0,guardrails:e.guardrails}),hotp:s=>G({...n,counter:s,guardrails:e.guardrails})})}function T(t){let e=l(t),{secret:r,crypto:o,base32:i,algorithm:a,digits:p}=e,n={secret:r,crypto:o,base32:i,algorithm:a,digits:p};return u(e.strategy,e.counter,{totp:()=>D({...n,period:e.period,epoch:e.epoch,t0:e.t0,guardrails:e.guardrails}),hotp:s=>H({...n,counter:s,guardrails:e.guardrails})})}async function P(t){let e=f(t),{secret:r,token:o,crypto:i,base32:a,algorithm:p,digits:n}=e,s={secret:r,token:o,crypto:i,base32:a,algorithm:p,digits:n};return u(e.strategy,e.counter,{totp:()=>U({...s,period:e.period,epoch:e.epoch,t0:e.t0,epochTolerance:e.epochTolerance,guardrails:e.guardrails}),hotp:y=>v({...s,counter:y,counterTolerance:e.counterTolerance,guardrails:e.guardrails})})}function h(t){let e=f(t),{secret:r,token:o,crypto:i,base32:a,algorithm:p,digits:n}=e,s={secret:r,token:o,crypto:i,base32:a,algorithm:p,digits:n};return u(e.strategy,e.counter,{totp:()=>w({...s,period:e.period,epoch:e.epoch,t0:e.t0,epochTolerance:e.epochTolerance,guardrails:e.guardrails}),hotp:y=>C({...s,counter:y,counterTolerance:e.counterTolerance,guardrails:e.guardrails})})}import{generateSecret as k}from"@otplib/core";var d=class{strategy;crypto;base32;constructor(e={}){let{strategy:r="totp",crypto:o=c,base32:i=g}=e;this.strategy=r,this.crypto=o,this.base32=i}getStrategy(){return this.strategy}generateSecret(e=20){return k({crypto:this.crypto,base32:this.base32,length:e})}async generate(e){return m({...e,strategy:this.strategy,crypto:this.crypto,base32:this.base32})}generateSync(e){return T({...e,strategy:this.strategy,crypto:this.crypto,base32:this.base32})}async verify(e){return P({...e,strategy:this.strategy,crypto:this.crypto,base32:this.base32})}verifySync(e){return h({...e,strategy:this.strategy,crypto:this.crypto,base32:this.base32})}generateURI(e){return O({...e,strategy:this.strategy})}};import{createGuardrails as re}from"@otplib/core";import{HOTP as ie}from"@otplib/hotp";import{TOTP as se}from"@otplib/totp";import{wrapResult as pe,wrapResultAsync as ye}from"@otplib/core";import{NobleCryptoPlugin as ge}from"@otplib/plugin-crypto-noble";import{ScureBase32Plugin as le}from"@otplib/plugin-base32-scure";export{ie as HOTP,ge as NobleCryptoPlugin,d as OTP,le as ScureBase32Plugin,se as TOTP,re as createGuardrails,m as generate,j as generateSecret,T as generateSync,O as generateURI,P as verify,h as verifySync,pe as wrapResult,ye as wrapResultAsync};
//# sourceMappingURL=index.js.map