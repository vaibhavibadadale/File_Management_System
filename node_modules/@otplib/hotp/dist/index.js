import{counterToBytes as N,createCryptoContext as w,createGuardrails as D,dynamicTruncate as T,truncateDigits as h,validateCounter as H,validateSecret as b,validateToken as U,validateCounterTolerance as j,normalizeSecret as C,normalizeCounterTolerance as z,requireSecret as x,requireCryptoPlugin as G}from"@otplib/core";import{generateSecret as B,requireCryptoPlugin as y,requireBase32Plugin as g,requireSecret as f,requireLabel as S,requireIssuer as q,requireBase32String as k,createGuardrails as I}from"@otplib/core";import{generateHOTP as A}from"@otplib/uri";var m=class{options;guardrails;constructor(t={}){this.options=t,this.guardrails=I(t.guardrails)}generateSecret(){let{crypto:t,base32:e}=this.options;return y(t),g(e),B({crypto:t,base32:e})}async generate(t,e){let s={...this.options,...e},{secret:n,crypto:o,base32:r,algorithm:i="sha1",digits:a=6}=s;f(n),y(o),g(r);let u=e?.guardrails??this.guardrails;return O({secret:n,counter:t,algorithm:i,digits:a,crypto:o,base32:r,guardrails:u})}async verify(t,e){let s={...this.options,...e},{secret:n,crypto:o,base32:r,algorithm:i="sha1",digits:a=6,counterTolerance:u=0}=s;f(n),y(o),g(r);let p=e?.guardrails??this.guardrails;return P({secret:n,token:t.token,counter:t.counter,algorithm:i,digits:a,counterTolerance:u,crypto:o,base32:r,guardrails:p})}toURI(t=0){let{issuer:e,label:s,secret:n,algorithm:o="sha1",digits:r=6}=this.options;return f(n),S(s),q(e),k(n),A({issuer:e,label:s,secret:n,algorithm:o,digits:r,counter:t})}};import{wrapResult as Z,wrapResultAsync as _}from"@otplib/core";function V(c){let{secret:t,counter:e,algorithm:s="sha1",digits:n=6,crypto:o,base32:r,guardrails:i}=c;x(t),G(o);let a=C(t,r);b(a,i),H(e,i);let u=w(o),p=N(e);return{ctx:u,algorithm:s,digits:n,secretBytes:a,counterBytes:p}}async function O(c){let{ctx:t,algorithm:e,digits:s,secretBytes:n,counterBytes:o}=V(c),r=await t.hmac(e,n,o),i=T(r);return h(i,s)}function E(c){let{ctx:t,algorithm:e,digits:s,secretBytes:n,counterBytes:o}=V(c),r=t.hmacSync(e,n,o),i=T(r);return h(i,s)}function v(c){let{secret:t,counter:e,token:s,algorithm:n="sha1",digits:o=6,crypto:r,base32:i,counterTolerance:a=0,guardrails:u=D()}=c;x(t),G(r);let p=C(t,i);b(p,u),H(e,u),U(s,o),j(a,u);let d=typeof e=="bigint"?Number(e):e,R=z(a).filter(l=>d+l>=0);return{token:s,counterNum:d,offsets:R,crypto:r,getGenerateOptions:l=>({secret:p,counter:l,algorithm:n,digits:o,crypto:r,guardrails:u})}}async function P(c){let{token:t,counterNum:e,offsets:s,crypto:n,getGenerateOptions:o}=v(c);for(let r of s){let i=e+r,a=await O(o(i));if(n.constantTimeEqual(a,t))return{valid:!0,delta:r}}return{valid:!1}}function Q(c){let{token:t,counterNum:e,offsets:s,crypto:n,getGenerateOptions:o}=v(c);for(let r of s){let i=e+r,a=E(o(i));if(n.constantTimeEqual(a,t))return{valid:!0,delta:r}}return{valid:!1}}export{m as HOTP,O as generate,E as generateSync,P as verify,Q as verifySync,Z as wrapResult,_ as wrapResultAsync};
//# sourceMappingURL=index.js.map