"use strict";var d=Object.defineProperty;var G=Object.getOwnPropertyDescriptor;var V=Object.getOwnPropertyNames;var v=Object.prototype.hasOwnProperty;var R=(c,e)=>{for(var r in e)d(c,r,{get:e[r],enumerable:!0})},B=(c,e,r,s)=>{if(e&&typeof e=="object"||typeof e=="function")for(let n of V(e))!v.call(c,n)&&n!==r&&d(c,n,{get:()=>e[n],enumerable:!(s=G(e,n))||s.enumerable});return c};var S=c=>B(d({},"__esModule",{value:!0}),c);var k={};R(k,{HOTP:()=>g,generate:()=>f,generateSync:()=>b,verify:()=>P,verifySync:()=>q,wrapResult:()=>m.wrapResult,wrapResultAsync:()=>m.wrapResultAsync});module.exports=S(k);var t=require("@otplib/core");var i=require("@otplib/core"),h=require("@otplib/uri");var g=class{options;guardrails;constructor(e={}){this.options=e,this.guardrails=(0,i.createGuardrails)(e.guardrails)}generateSecret(){let{crypto:e,base32:r}=this.options;return(0,i.requireCryptoPlugin)(e),(0,i.requireBase32Plugin)(r),(0,i.generateSecret)({crypto:e,base32:r})}async generate(e,r){let s={...this.options,...r},{secret:n,crypto:a,base32:o,algorithm:u="sha1",digits:p=6}=s;(0,i.requireSecret)(n),(0,i.requireCryptoPlugin)(a),(0,i.requireBase32Plugin)(o);let l=r?.guardrails??this.guardrails;return f({secret:n,counter:e,algorithm:u,digits:p,crypto:a,base32:o,guardrails:l})}async verify(e,r){let s={...this.options,...r},{secret:n,crypto:a,base32:o,algorithm:u="sha1",digits:p=6,counterTolerance:l=0}=s;(0,i.requireSecret)(n),(0,i.requireCryptoPlugin)(a),(0,i.requireBase32Plugin)(o);let y=r?.guardrails??this.guardrails;return P({secret:n,token:e.token,counter:e.counter,algorithm:u,digits:p,counterTolerance:l,crypto:a,base32:o,guardrails:y})}toURI(e=0){let{issuer:r,label:s,secret:n,algorithm:a="sha1",digits:o=6}=this.options;return(0,i.requireSecret)(n),(0,i.requireLabel)(s),(0,i.requireIssuer)(r),(0,i.requireBase32String)(n),(0,h.generateHOTP)({issuer:r,label:s,secret:n,algorithm:a,digits:o,counter:e})}};var m=require("@otplib/core");function H(c){let{secret:e,counter:r,algorithm:s="sha1",digits:n=6,crypto:a,base32:o,guardrails:u}=c;(0,t.requireSecret)(e),(0,t.requireCryptoPlugin)(a);let p=(0,t.normalizeSecret)(e,o);(0,t.validateSecret)(p,u),(0,t.validateCounter)(r,u);let l=(0,t.createCryptoContext)(a),y=(0,t.counterToBytes)(r);return{ctx:l,algorithm:s,digits:n,secretBytes:p,counterBytes:y}}async function f(c){let{ctx:e,algorithm:r,digits:s,secretBytes:n,counterBytes:a}=H(c),o=await e.hmac(r,n,a),u=(0,t.dynamicTruncate)(o);return(0,t.truncateDigits)(u,s)}function b(c){let{ctx:e,algorithm:r,digits:s,secretBytes:n,counterBytes:a}=H(c),o=e.hmacSync(r,n,a),u=(0,t.dynamicTruncate)(o);return(0,t.truncateDigits)(u,s)}function C(c){let{secret:e,counter:r,token:s,algorithm:n="sha1",digits:a=6,crypto:o,base32:u,counterTolerance:p=0,guardrails:l=(0,t.createGuardrails)()}=c;(0,t.requireSecret)(e),(0,t.requireCryptoPlugin)(o);let y=(0,t.normalizeSecret)(e,u);(0,t.validateSecret)(y,l),(0,t.validateCounter)(r,l),(0,t.validateToken)(s,a),(0,t.validateCounterTolerance)(p,l);let T=typeof r=="bigint"?Number(r):r,x=(0,t.normalizeCounterTolerance)(p).filter(O=>T+O>=0);return{token:s,counterNum:T,offsets:x,crypto:o,getGenerateOptions:O=>({secret:y,counter:O,algorithm:n,digits:a,crypto:o,guardrails:l})}}async function P(c){let{token:e,counterNum:r,offsets:s,crypto:n,getGenerateOptions:a}=C(c);for(let o of s){let u=r+o,p=await f(a(u));if(n.constantTimeEqual(p,e))return{valid:!0,delta:o}}return{valid:!1}}function q(c){let{token:e,counterNum:r,offsets:s,crypto:n,getGenerateOptions:a}=C(c);for(let o of s){let u=r+o,p=b(a(u));if(n.constantTimeEqual(p,e))return{valid:!0,delta:o}}return{valid:!1}}0&&(module.exports={HOTP,generate,generateSync,verify,verifySync,wrapResult,wrapResultAsync});
//# sourceMappingURL=index.cjs.map