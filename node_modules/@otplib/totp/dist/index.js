import{createGuardrails as g,normalizeSecret as x,normalizeEpochTolerance as L,validateEpochTolerance as j,validatePeriod as m,validateSecret as G,validateTime as f,validateToken as z,requireSecret as V,requireCryptoPlugin as v}from"@otplib/core";import{generate as F,generateSync as J}from"@otplib/hotp";import{generateSecret as k,requireCryptoPlugin as y,requireBase32Plugin as d,requireSecret as h,requireLabel as A,requireIssuer as H,requireBase32String as B,createGuardrails as E}from"@otplib/core";import{generateTOTP as U}from"@otplib/uri";var P=class{options;guardrails;constructor(e={}){this.options=e,this.guardrails=E(e.guardrails)}generateSecret(){let{crypto:e,base32:r}=this.options;return y(e),d(r),k({crypto:e,base32:r})}async generate(e){let r={...this.options,...e},{secret:i,crypto:o,base32:n,algorithm:c="sha1",digits:l=6,period:u=30,epoch:t,t0:a=0}=r;h(i),y(o),d(n);let p=e?.guardrails??this.guardrails;return b({secret:i,algorithm:c,digits:l,period:u,epoch:t??Math.floor(Date.now()/1e3),t0:a,crypto:o,base32:n,guardrails:p})}async verify(e,r){let i={...this.options,...r},{secret:o,crypto:n,base32:c,algorithm:l="sha1",digits:u=6,period:t=30,epoch:a,t0:p=0,epochTolerance:T=0}=i;h(o),y(n),d(c);let O=r?.guardrails??this.guardrails;return C({secret:o,token:e,algorithm:l,digits:u,period:t,epoch:a??Math.floor(Date.now()/1e3),t0:p,epochTolerance:T,crypto:n,base32:c,guardrails:O})}toURI(e){let{issuer:r,label:i,secret:o,algorithm:n="sha1",digits:c=6,period:l=30}=this.options,u=e?.label??i,t=e?.issuer??r,a=e?.secret??o;return h(a),A(u),H(t),B(a),U({issuer:t,label:u,secret:a,algorithm:n,digits:c,period:l})}};import{wrapResult as oe,wrapResultAsync as ie}from"@otplib/core";function S(s){let{secret:e,epoch:r=Math.floor(Date.now()/1e3),t0:i=0,period:o=30,algorithm:n="sha1",digits:c=6,crypto:l,base32:u,guardrails:t=g()}=s;V(e),v(l);let a=x(e,u);G(a,t),f(r),m(o,t);let p=Math.floor((r-i)/o);return{secret:a,counter:p,algorithm:n,digits:c,crypto:l,guardrails:t}}async function b(s){let e=S(s);return F(e)}function K(s){let e=S(s);return J(e)}function R(s){let{secret:e,token:r,epoch:i=Math.floor(Date.now()/1e3),t0:o=0,period:n=30,algorithm:c="sha1",digits:l=6,crypto:u,base32:t,epochTolerance:a=0,guardrails:p=g()}=s;V(e),v(u);let T=x(e,t);G(T,p),f(i),m(n,p),z(r,l),j(a,n,p);let O=Math.floor((i-o)/n),[M,q]=L(a),I=Math.max(0,Math.floor((i-M-o)/n)),w=Math.floor((i+q-o)/n);return{token:r,crypto:u,minCounter:I,maxCounter:w,currentCounter:O,t0:o,period:n,getGenerateOptions:D=>({secret:T,epoch:D*n+o,t0:o,period:n,algorithm:c,digits:l,crypto:u,guardrails:p})}}async function C(s){let{token:e,crypto:r,minCounter:i,maxCounter:o,currentCounter:n,t0:c,period:l,getGenerateOptions:u}=R(s);for(let t=i;t<=o;t++){let a=await b(u(t));if(r.constantTimeEqual(a,e))return{valid:!0,delta:t-n,epoch:t*l+c}}return{valid:!1}}function _(s){let{token:e,crypto:r,minCounter:i,maxCounter:o,currentCounter:n,t0:c,period:l,getGenerateOptions:u}=R(s);for(let t=i;t<=o;t++){let a=K(u(t));if(r.constantTimeEqual(a,e))return{valid:!0,delta:t-n,epoch:t*l+c}}return{valid:!1}}function $(s=Math.floor(Date.now()/1e3),e=30,r=0,i=g()){return f(s),m(e,i),(Math.floor((s-r)/e)+1)*e+r-s}function ee(s=Math.floor(Date.now()/1e3),e=30,r=0,i=g()){return f(s),m(e,i),Math.floor((s-r)/e)}export{P as TOTP,b as generate,K as generateSync,$ as getRemainingTime,ee as getTimeStepUsed,C as verify,_ as verifySync,oe as wrapResult,ie as wrapResultAsync};
//# sourceMappingURL=index.js.map