"use strict";var H=Object.defineProperty;var kr=Object.getOwnPropertyDescriptor;var Lr=Object.getOwnPropertyNames;var Gr=Object.prototype.hasOwnProperty;var Xr=(r,e)=>{for(var t in e)H(r,t,{get:e[t],enumerable:!0})},$r=(r,e,t,o)=>{if(e&&typeof e=="object"||typeof e=="function")for(let n of Lr(e))!Gr.call(r,n)&&n!==t&&H(r,n,{get:()=>e[n],enumerable:!(o=kr(e,n))||o.enumerable});return r};var Yr=r=>$r(H({},"__esModule",{value:!0}),r);var zr={};Xr(zr,{AlgorithmError:()=>W,Base32Context:()=>$,Base32DecodeError:()=>S,Base32EncodeError:()=>C,Base32Error:()=>B,Base32PluginMissingError:()=>U,ConfigurationError:()=>u,CounterError:()=>d,CounterNegativeError:()=>E,CounterOverflowError:()=>T,CounterToleranceError:()=>G,CounterToleranceTooLargeError:()=>w,CryptoContext:()=>X,CryptoError:()=>b,CryptoPluginMissingError:()=>I,DEFAULT_PERIOD:()=>Z,DigitsError:()=>Y,EpochToleranceError:()=>R,EpochToleranceNegativeError:()=>_,EpochToleranceTooLargeError:()=>M,HMACError:()=>a,IssuerMissingError:()=>q,LabelMissingError:()=>N,MAX_COUNTER:()=>rr,MAX_PERIOD:()=>Q,MAX_SECRET_BYTES:()=>F,MAX_WINDOW:()=>er,MIN_PERIOD:()=>J,MIN_SECRET_BYTES:()=>j,OTPError:()=>s,PeriodError:()=>x,PeriodTooLargeError:()=>f,PeriodTooSmallError:()=>y,PluginError:()=>v,RECOMMENDED_SECRET_BYTES:()=>V,RandomBytesError:()=>A,SecretError:()=>p,SecretMissingError:()=>D,SecretTooLongError:()=>g,SecretTooShortError:()=>l,SecretTypeError:()=>k,TimeError:()=>L,TimeNegativeError:()=>m,TokenError:()=>h,TokenFormatError:()=>O,TokenLengthError:()=>P,constantTimeEqual:()=>yr,counterToBytes:()=>Tr,createBase32Context:()=>Ur,createCryptoContext:()=>Ir,createGuardrails:()=>ir,dynamicTruncate:()=>mr,generateSecret:()=>Or,getDigestSize:()=>fr,hasBase32:()=>qr,hasCrypto:()=>Nr,hasGuardrailOverrides:()=>ar,hasPlugins:()=>Dr,hexToBytes:()=>hr,normalizeCounterTolerance:()=>br,normalizeEpochTolerance:()=>Ar,normalizeSecret:()=>Pr,requireBase32Plugin:()=>K,requireBase32String:()=>wr,requireCryptoPlugin:()=>or,requireIssuer:()=>Sr,requireLabel:()=>Cr,requireSecret:()=>Br,stringToBytes:()=>z,truncateDigits:()=>xr,validateByteLengthEqual:()=>nr,validateCounter:()=>cr,validateCounterTolerance:()=>dr,validateEpochTolerance:()=>Er,validatePeriod:()=>lr,validateSecret:()=>ur,validateTime:()=>pr,validateToken:()=>gr,wrapResult:()=>Mr,wrapResultAsync:()=>vr});module.exports=Yr(zr);var s=class extends Error{constructor(e,t){super(e,t),this.name="OTPError"}},p=class extends s{constructor(e){super(e),this.name="SecretError"}},l=class extends p{constructor(e,t){super(`Secret must be at least ${e} bytes (${e*8} bits), got ${t} bytes`),this.name="SecretTooShortError"}},g=class extends p{constructor(e,t){super(`Secret must not exceed ${e} bytes, got ${t} bytes`),this.name="SecretTooLongError"}},d=class extends s{constructor(e){super(e),this.name="CounterError"}},E=class extends d{constructor(){super("Counter must be non-negative"),this.name="CounterNegativeError"}},T=class extends d{constructor(){super("Counter exceeds maximum safe integer value"),this.name="CounterOverflowError"}},L=class extends s{constructor(e){super(e),this.name="TimeError"}},m=class extends L{constructor(){super("Time must be non-negative"),this.name="TimeNegativeError"}},x=class extends s{constructor(e){super(e),this.name="PeriodError"}},y=class extends x{constructor(e){super(`Period must be at least ${e} second(s)`),this.name="PeriodTooSmallError"}},f=class extends x{constructor(e){super(`Period must not exceed ${e} seconds`),this.name="PeriodTooLargeError"}},Y=class extends s{constructor(e){super(e),this.name="DigitsError"}},W=class extends s{constructor(e){super(e),this.name="AlgorithmError"}},h=class extends s{constructor(e){super(e),this.name="TokenError"}},P=class extends h{constructor(e,t){super(`Token must be ${e} digits, got ${t}`),this.name="TokenLengthError"}},O=class extends h{constructor(){super("Token must contain only digits"),this.name="TokenFormatError"}},b=class extends s{constructor(e,t){super(e,t),this.name="CryptoError"}},a=class extends b{constructor(e,t){super(`HMAC computation failed: ${e}`,t),this.name="HMACError"}},A=class extends b{constructor(e,t){super(`Random byte generation failed: ${e}`,t),this.name="RandomBytesError"}},B=class extends s{constructor(e,t){super(e,t),this.name="Base32Error"}},C=class extends B{constructor(e,t){super(`Base32 encoding failed: ${e}`,t),this.name="Base32EncodeError"}},S=class extends B{constructor(e,t){super(`Base32 decoding failed: ${e}`,t),this.name="Base32DecodeError"}},G=class extends s{constructor(e){super(e),this.name="CounterToleranceError"}},w=class extends G{constructor(e,t){super(`Counter tolerance size must not exceed ${e}, got ${t}. Large tolerances can cause performance issues.`),this.name="CounterToleranceTooLargeError"}},R=class extends s{constructor(e){super(e),this.name="EpochToleranceError"}},_=class extends R{constructor(){super("Epoch tolerance cannot contain negative values"),this.name="EpochToleranceNegativeError"}},M=class extends R{constructor(e,t){super(`Epoch tolerance must not exceed ${e} seconds, got ${t}. Large tolerances can cause performance issues.`),this.name="EpochToleranceTooLargeError"}},v=class extends s{constructor(e){super(e),this.name="PluginError"}},I=class extends v{constructor(){super("Crypto plugin is required."),this.name="CryptoPluginMissingError"}},U=class extends v{constructor(){super("Base32 plugin is required."),this.name="Base32PluginMissingError"}},u=class extends s{constructor(e){super(e),this.name="ConfigurationError"}},D=class extends u{constructor(){super("Secret is required. Use generateSecret() to create one, or provide via { secret: 'YOUR_BASE32_SECRET' }"),this.name="SecretMissingError"}},N=class extends u{constructor(){super("Label is required for URI generation. Example: { label: 'user@example.com' }"),this.name="LabelMissingError"}},q=class extends u{constructor(){super("Issuer is required for URI generation. Example: { issuer: 'MyApp' }"),this.name="IssuerMissingError"}},k=class extends u{constructor(){super("Class API requires secret to be a Base32 string, not Uint8Array. Use generateSecret() or provide a Base32-encoded string."),this.name="SecretTypeError"}};var Wr=new TextEncoder,j=16,F=64,V=20,J=1,Q=3600,Z=30,rr=Number.MAX_SAFE_INTEGER,er=100,tr=Symbol("otplib.guardrails.override"),c=Object.freeze({MIN_SECRET_BYTES:j,MAX_SECRET_BYTES:F,MIN_PERIOD:J,MAX_PERIOD:Q,MAX_COUNTER:rr,MAX_WINDOW:er,[tr]:!1});function ir(r){return r?Object.freeze({...c,...r,[tr]:!0}):c}function ar(r){return r[tr]??!1}function ur(r,e=c){if(r.length<e.MIN_SECRET_BYTES)throw new l(e.MIN_SECRET_BYTES,r.length);if(r.length>e.MAX_SECRET_BYTES)throw new g(e.MAX_SECRET_BYTES,r.length)}function cr(r,e=c){let t=typeof r=="bigint"?r:BigInt(r);if(t<0n)throw new E;if(t>BigInt(e.MAX_COUNTER))throw new T}function pr(r){if(r<0)throw new m}function lr(r,e=c){if(!Number.isInteger(r)||r<e.MIN_PERIOD)throw new y(e.MIN_PERIOD);if(r>e.MAX_PERIOD)throw new f(e.MAX_PERIOD)}function gr(r,e){if(r.length!==e)throw new P(e,r.length);if(!/^\d+$/.test(r))throw new O}function dr(r,e=c){if((Array.isArray(r)?r.length:r*2+1)>e.MAX_WINDOW*2+1)throw new w(e.MAX_WINDOW,Array.isArray(r)?r.length:r)}function Er(r,e=Z,t=c){let[o,n]=Array.isArray(r)?r:[r,r];if(o<0||n<0)throw new _;let i=t.MAX_WINDOW*e,sr=Math.max(o,n);if(sr>i)throw new M(i,sr)}function Tr(r){let e=typeof r=="bigint"?r:BigInt(r),t=new ArrayBuffer(8);return new DataView(t).setBigUint64(0,e,!1),new Uint8Array(t)}function mr(r){let e=r[r.length-1]&15;return(r[e]&127)<<24|r[e+1]<<16|r[e+2]<<8|r[e+3]}function xr(r,e){let t=10**e;return(r%t).toString().padStart(e,"0")}function nr(r,e){return r.length===e.length}function yr(r,e){let t=z(r),o=z(e);if(!nr(t,o))return!1;let n=0;for(let i=0;i<t.length;i++)n|=t[i]^o[i];return n===0}function fr(r){switch(r){case"sha1":return 20;case"sha256":return 32;case"sha512":return 64}}function z(r){return typeof r=="string"?Wr.encode(r):r}function hr(r){let e=new Uint8Array(r.length/2);for(let t=0;t<r.length;t+=2)e[t/2]=parseInt(r.substring(t,t+2),16);return e}function Pr(r,e){return typeof r=="string"?(K(e),e.decode(r)):r}function Or(r){let{crypto:e,base32:t,length:o=V}=r;or(e),K(t);let n=e.randomBytes(o);return t.encode(n,{padding:!1})}function br(r=0){if(Array.isArray(r))return r;let e=[];for(let t=-r;t<=r;t++)e.push(t|0);return e}function Ar(r=0){return Array.isArray(r)?r:[r,r]}function or(r){if(!r)throw new I}function K(r){if(!r)throw new U}function Br(r){if(!r)throw new D}function Cr(r){if(!r)throw new N}function Sr(r){if(!r)throw new q}function wr(r){if(typeof r!="string")throw new k}function Rr(r){return{ok:!0,value:r}}function _r(r){return{ok:!1,error:r}}function Mr(r){return(...e)=>{try{return Rr(r(...e))}catch(t){return _r(t)}}}function vr(r){return async(...e)=>{try{return Rr(await r(...e))}catch(t){return _r(t)}}}var X=class{constructor(e){this.crypto=e}get plugin(){return this.crypto}async hmac(e,t,o){try{let n=this.crypto.hmac(e,t,o);return n instanceof Promise?await n:n}catch(n){let i=n instanceof Error?n.message:String(n);throw new a(i,{cause:n})}}hmacSync(e,t,o){try{let n=this.crypto.hmac(e,t,o);if(n instanceof Promise)throw new a("Crypto plugin does not support synchronous HMAC operations");return n}catch(n){if(n instanceof a)throw n;let i=n instanceof Error?n.message:String(n);throw new a(i,{cause:n})}}randomBytes(e){try{return this.crypto.randomBytes(e)}catch(t){let o=t instanceof Error?t.message:String(t);throw new A(o,{cause:t})}}};function Ir(r){return new X(r)}var $=class{constructor(e){this.base32=e}get plugin(){return this.base32}encode(e,t){try{return this.base32.encode(e,t)}catch(o){let n=o instanceof Error?o.message:String(o);throw new C(n,{cause:o})}}decode(e){try{return this.base32.decode(e)}catch(t){let o=t instanceof Error?t.message:String(t);throw new S(o,{cause:t})}}};function Ur(r){return new $(r)}function Dr(r){return r.crypto!==void 0&&r.base32!==void 0}function Nr(r){return r.crypto!==void 0}function qr(r){return r.base32!==void 0}0&&(module.exports={AlgorithmError,Base32Context,Base32DecodeError,Base32EncodeError,Base32Error,Base32PluginMissingError,ConfigurationError,CounterError,CounterNegativeError,CounterOverflowError,CounterToleranceError,CounterToleranceTooLargeError,CryptoContext,CryptoError,CryptoPluginMissingError,DEFAULT_PERIOD,DigitsError,EpochToleranceError,EpochToleranceNegativeError,EpochToleranceTooLargeError,HMACError,IssuerMissingError,LabelMissingError,MAX_COUNTER,MAX_PERIOD,MAX_SECRET_BYTES,MAX_WINDOW,MIN_PERIOD,MIN_SECRET_BYTES,OTPError,PeriodError,PeriodTooLargeError,PeriodTooSmallError,PluginError,RECOMMENDED_SECRET_BYTES,RandomBytesError,SecretError,SecretMissingError,SecretTooLongError,SecretTooShortError,SecretTypeError,TimeError,TimeNegativeError,TokenError,TokenFormatError,TokenLengthError,constantTimeEqual,counterToBytes,createBase32Context,createCryptoContext,createGuardrails,dynamicTruncate,generateSecret,getDigestSize,hasBase32,hasCrypto,hasGuardrailOverrides,hasPlugins,hexToBytes,normalizeCounterTolerance,normalizeEpochTolerance,normalizeSecret,requireBase32Plugin,requireBase32String,requireCryptoPlugin,requireIssuer,requireLabel,requireSecret,stringToBytes,truncateDigits,validateByteLengthEqual,validateCounter,validateCounterTolerance,validateEpochTolerance,validatePeriod,validateSecret,validateTime,validateToken,wrapResult,wrapResultAsync});
//# sourceMappingURL=index.cjs.map